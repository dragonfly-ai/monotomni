package ai.dragonfly.distributed.monotomni

import java.nio.ByteBuffer
import java.util.concurrent.atomic.AtomicInteger

import scala.xml
import scala.util.matching.Regex
import scala.xml.{Elem, Node}

object TimeTrial {
  /* Binary TimeTrial Utilities */
  /** The number of Bytes required to represent a TimeTrial value in two's complement binary form. */
  val BYTES:Int = 2 * java.lang.Integer.BYTES + java.lang.Long.BYTES

  /**
   * Parses TimeTrial object from a byte Array.
   * This only matches the exact format generated by [[ai.dragonfly.distributed.monotomni.TimeTrial.BINARY]]: e.g. {{{Array[Byte](0, ffffffea, b, ffffffbb, b, ffffffff, 12, ffffffc)}}}
   * @param bytes an array of bytes that encodes a TimeTrial object.
   * @return the TimeTrial object encoded as: {{{Array[Byte]}}}
   */
  def BINARY(bytes: Array[Byte]): TimeTrial = {
    if (bytes.length == BYTES) {
      val bb = java.nio.ByteBuffer.wrap(bytes)
      TimeTrial(bb.getInt(0), bb.getInt(4), bb.getLong(8))
    } else throw InvalidTimeTrialBinary(bytes)
  }

  private def parseException(sc:StringContext, s:String):Exception = sc match {
    case sc1 if sc1 == scSTRING => InvalidTimeTrialString(s)
    case sc1 if sc1 == scJSON => InvalidTimeTrialJSON(s)
    case sc1 if sc1 == scJSONP => InvalidTimeTrialJSONP(s)
    case sc1 if sc1 == scXML => InvalidTimeTrialXML(s)
  }

  private def parse(sc:StringContext, s:String):TimeTrial = {
    val seq:Option[Seq[String]] = try { sc.s.unapplySeq(s.trim()) } catch { case _:Throwable => throw parseException(sc, s) }
    seq match {
      case Some(Seq(N2Int(sid),N2Int(t),N2Long(ts))) => TimeTrial(Integer.parseInt(sid), Integer.parseInt(t), java.lang.Long.parseLong(ts))
      case Some(Seq(sid, t, ts)) => throw InvalidTimeTrialParameters(sid, t, ts)
      case _ => throw parseException(sc,s)
    }
  }

  private val scSTRING: StringContext = StringContext("", ":", ":", "")

  /**
   * Parses TimeTrial object from a plain text String.
   * This only matches the exact format generated by [[ai.dragonfly.distributed.monotomni.TimeTrial.STRING]]: e.g. `42:3:1614218679808`
   * @param s a String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the String
   */
  def STRING(s:String): TimeTrial = parse(scSTRING, s)

  private val scJSON: StringContext = StringContext("{\"sid\":", ",\"t\":", ",\"ts\":\"", "\"}")

  /**
   * Parses TimeTrial object from JSON String.
   * This does not parse generally formatted JSON! It only matches the exact format generated by [[ai.dragonfly.distributed.monotomni.TimeTrial.JSON]]: e.g. `{"sid":42,"t":3,"ts":"1614218679808"}`
   * @param rawJSON a JSON String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the JSON String
   */
  def JSON(rawJSON:String):TimeTrial = parse(scJSON, rawJSON)

  private val scJSONP = StringContext("function SYNCH_SERVERTIME(){ if ( typeof LOG_TIME_TRIAL === 'undefined' ) { setTimeout(SYNCH_SERVERTIME, 500); } else { LOG_TIME_TRIAL(", ",", ",\"", "\"); } } setTimeout(SYNCH_SERVERTIME, 1);")
  /**
   * Parses TimeTrial object from JSONP Response Body.
   * Browser environments don't need this method but JVM or Node.js clients can use it to support JSONP calls made from repurposed browser applications, for testing, or for validating server responses.
   * This does not parse generally formatted JavaScript! It matches the exact format generated by [[ai.dragonfly.distributed.monotomni.TimeTrial.JSONP]]
   * @param rawJSONP a JSON String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the JSON String
   */
  def JSONP(rawJSONP:String):TimeTrial = parse(scJSONP, rawJSONP)

  private val scXML: StringContext = StringContext("<TimeTrial sid=\"", "\" t=\"", "\" ts=\"","\"/>")
  /**
   * Parses TimeTrial object from XML String.
   * This does not parse generally formatted XML! It only matches the exact format generated by [[ai.dragonfly.distributed.monotomni.TimeTrial.XML]]: e.g. {{{<TimeTrial sid="42" trial="96" serverTimeStamp="1614269593663" />}}}
   * @param rawXML an XML String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the XML String
   */
  def XML(rawXML:String):TimeTrial = parse(scXML, rawXML)


  def test():Unit = {
    import scala.language.implicitConversions
    implicit def int2Byte(i: Int):Byte = i.toByte

    val aI:AtomicInteger = new AtomicInteger(0)

    trait Assertion {
      val testId:Int
      val passes:Boolean
      val f:() => TimeTrial
      def apply():Unit = try {
        val tt:TimeTrial = f()
        println(s"Test $testId ${if (passes) "passed as expected" else "UNEXPECTEDLY passed" } yielding: $tt")
      } catch {
        case t:Throwable =>
          println(s"Test $testId ${if (passes) "UNEXPECTEDLY failed" else "failed as expected" } with Exception: $t")
      }
    }

    case class Passes(override val f:() => TimeTrial) extends Assertion {
      override val testId:Int = aI.getAndIncrement()
      override val passes = true
      apply()
    }
    case class Fails(override val f:() => TimeTrial) extends Assertion {
      override val testId:Int = aI.getAndIncrement()
      override val passes = false
      apply()
    }

    Passes( () => TimeTrial.BINARY(TimeTrial(42, 1).BINARY) )
    Fails( () => TimeTrial.BINARY(Array[Byte](0xff)) )
    Passes( () => TimeTrial.BINARY(Array[Byte](0x0, 0x0, 0x0, 0xcb,0xf, 0xa, 0xb, 0xff, 0x12, 0xf, 0xa, 0xb, 0x0, 0xc, 0x1, 0xf)) )
    Fails( () => TimeTrial.BINARY(Array[Byte](0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0xf)) )
    Passes( () => TimeTrial.STRING(TimeTrial(42, 1).STRING) )
    Fails( () => TimeTrial.STRING("Blah Blah Blah. ERRROR!") )
    Fails( () => TimeTrial.STRING(scSTRING.s("58192516957324799", "97657492195762495819251695732479919247957","16140136463221614013646322")) )
    Passes( () => TimeTrial.JSON(TimeTrial(42, 1).JSON) )
    Fails( () => TimeTrial.JSON("Blah Blah Blah. ERRROR!") )
    Fails( () => TimeTrial.JSON(scJSON.s("58192516957324799", "97657492195762495819251695732479919247957","16140136463221614013646322")) )
    Passes( () => TimeTrial.JSONP(TimeTrial(42, 1).JSONP) )
    Fails( () => TimeTrial.JSONP("Blah Blah Blah. ERRROR!") )
    Fails( () => TimeTrial.JSONP(scJSONP.s("58192516957324799", "161401364632216140136463221614013646322","97657492195762495819251694")) )
    Passes( () => TimeTrial.XML(TimeTrial(42, 96).XML))
    Passes( () => TimeTrial.XML(TimeTrial.scXML.s(Int.MaxValue, Int.MaxValue, Long.MaxValue)))
    Passes( () => TimeTrial.XML(<TimeTrial sid="42" t="96" ts="1614218679808" />.toString) )
    Fails( () => TimeTrial.XML("Blah Blah Blah. ERRROR!") )
    Fails( () => TimeTrial.XML(<TimeTrial sid="58192516957324799" t="58192516957324799" ts="97657492195762495819251695732479919247957" />.toString) )
    Fails( () => TimeTrial.XML(<TimeTrial sid="42" t="96" />.toString) )
    Fails( () => TimeTrial.XML(<TimeTrial sid="42" t="96" ts="1614218679808" extra="Mono+Omni" />.toString) )
    Fails( () => TimeTrial.XML(<TimeTrial serverId="42" trial="96" serverTimeStamp="1614218679808" />.toString) )
  }

}

case class TimeTrial(serverId: Int, trial:Int, serverTimeStamp:Long = System.currentTimeMillis()) {
  def BINARY:Array[Byte] = ByteBuffer.allocate(TimeTrial.BYTES).putInt(serverId).putInt(trial).putLong(serverTimeStamp).array()
  def STRING:String = TimeTrial.scSTRING.s(serverId, trial, serverTimeStamp)
  def JSON:String = TimeTrial.scJSON.s(serverId, trial, serverTimeStamp)
  def JSONP:String = TimeTrial.scJSONP.s(serverId, trial, serverTimeStamp)
  def XML:String = TimeTrial.scXML.s(serverId, trial, serverTimeStamp)
}

case class InvalidTimeTrialBinary(bytes:Array[Byte]) extends Exception(s"Invalid TimeTrial.  Expected length: ${TimeTrial.BYTES} but observed length: ${bytes.length} on ${byteArray2String(bytes)}")

case class InvalidTimeTrialString(s:String) extends Exception(s"""Invalid TimeTrial String: "$s"""")

case class InvalidTimeTrialJSON(rawJSON:String) extends Exception(s"""Invalid TimeTrial JSON: "$rawJSON"""")

case class InvalidTimeTrialJSONP(rawJSONP:String) extends Exception(s"""Invalid TimeTrial JSONP: "$rawJSONP"""")

object InvalidTimeTrialParameters {
  private def errorMessage(ok:Boolean, s:String, typeName:String):String = s"$s${ if (ok) " // OK!" else s" // ERROR! Can't read $typeName."}"
  def int(i:String):String =  errorMessage(N2Int.matches(i), i+",", "Int")
  def long(l:String):String =  errorMessage(N2Long.matches(l), l, "Long")
}

case class InvalidTimeTrialParameters(sid:String,t:String,ts:String) extends Exception({ import InvalidTimeTrialParameters._; s"Invalid TimeTrial Parameters:\n\tTimeTrial(\n\t\t${int(sid)}\n\t\t${int(t)}\n\t\t${long(ts)}\n\t)"})

case class InvalidTimeTrialXML(rawXML: String) extends Exception(s"""Invalid TimeTrial XML:\n\t"$rawXML"""")