package ai.dragonfly.monotomni

import java.io.{BufferedReader, InputStream, InputStreamReader}
import java.nio.ByteBuffer
import java.util.{Timer, TimerTask}
import java.util.concurrent.TimeoutException

import ai.dragonfly.distributed.Distributable

import scala.language.implicitConversions
import scala.concurrent.Promise
import scala.scalajs.js.annotation.JSExportAll

object TimeTrial extends native.TimeTrial {

  /** TimeTrialFormat enumeration as flags for content types supported by instances of TimeServerConnection. */
  object Formats extends Enumeration {
    def helpString:String = {
      val sb:StringBuilder = new StringBuilder("Time Server Documentation:\n")
      sb.append(s"\thttp://some.time.server.com/time/BINARY -> ${TimeTrial().BINARY.mkString("Array(", ", ", ")")} // just ${TimeTrial.BYTES} bytes.\n")
      sb.append(s"\thttps://some.time.server.com/time/BINARY -> ${TimeTrial().BINARY.mkString("Array(", ", ", ")")} // just ${TimeTrial.BYTES} bytes.\n")
      sb.append(s"\thttp://some.time.server.com/time/STRING -> ${TimeTrial().STRING}\n")
      sb.append(s"\thttps://some.time.server.com/time/STRING -> ${TimeTrial().STRING}\n")
      sb.append(s"\thttp://some.time.server.com/time/JSON -> ${TimeTrial().JSON}\n")
      sb.append(s"\thttps://some.time.server.com/time/JSON -> ${TimeTrial().JSON}\n")
      sb.append(s"\thttp://some.time.server.com/time/XML -> ${TimeTrial().XML}\n")
      sb.append(s"\thttps://some.time.server.com/time/XML -> ${TimeTrial().XML}\n")

      sb.append("TimeTrialJSONP requests respond with this javascript:\n")
      val moi:MOI = Mono+Omni()
      sb.append(s"\thttp://some.time.server.com/time/JSONP/$moi -> ${TimeTrialJSONP(moi, TimeTrial()).JSONP}\n")
      sb.append(s"\thttps://some.time.server.com/time/JSONP/$moi -> ${TimeTrialJSONP(moi, TimeTrial()).JSONP}\n")
      sb.toString()
    }
    type Format = Value
    @JSExportAll val BINARY, STRING, JSON, XML, JSONP = Value
    @JSExportAll val all:Seq[Format] = Seq[Format](BINARY, STRING, JSON, XML, JSONP)
  }

  /* Binary TimeTrial Utilities */
  /** The number of Bytes required to represent a TimeTrial value in two's complement binary form. */
  val BYTES:Int = java.lang.Long.BYTES

  /**
   * Parses TimeTrial object from a byte Array.
   * This only matches the exact format generated by [[ai.dragonfly.monotomni.TimeTrial.BINARY]]: e.g. {{{Array[Byte](b, ffffffff, 12, ffffffc)}}}
   * @param bytes an array of bytes that encodes a TimeTrial object.
   * @return the TimeTrial object encoded as: {{{Array[Byte]}}}
   */
  def BINARY(bytes: Array[Byte]): TimeTrial = {
    if (bytes.length == BYTES) {
      val bb = java.nio.ByteBuffer.wrap(bytes)
      TimeTrial(bb.getLong(0))
    } else throw InvalidTimeTrialBinary(bytes)
  }

  /**
   * Reads binary TimeTrial from input stream
   * @param inputStream an input stream to read a TimeTrial from.
   * @return TimeTrial
   */
  implicit def inputStreamToByteArray(inputStream: InputStream): Array[Byte] = {
    val bytes = new Array[Byte](TimeTrial.BYTES)
    inputStream.read(bytes)
    bytes
  }

  def fromInputStream(format:Formats.Format, inputStream: InputStream): TimeTrial = {
    format match {
      case Formats.BINARY => TimeTrial.BINARY(inputStream)
      case Formats.STRING => TimeTrial.STRING(inputStream)
      case Formats.JSON => TimeTrial.JSON(inputStream)
      case _ => TimeTrial.XML(inputStream)
    }
  }

  private def exceptionSelection(sc:StringContext, s:String):Exception = sc match {
    case sc1 if sc1 == scSTRING => InvalidTimeTrialString(s)
    case sc1 if sc1 == scJSON => InvalidTimeTrialJSON(s)
    case sc1 if sc1 == scXML => InvalidTimeTrialXML(s)
  }

  private def parse(sc:StringContext, s:String):TimeTrial = {
    val seq:Option[Seq[String]] = try { sc.s.unapplySeq(s.trim()) } catch { case _:Throwable => throw exceptionSelection(sc, s) }
    seq match {
      case Some(Seq(N2Long(t))) => TimeTrial(java.lang.Long.parseLong(t))
      case Some(Seq(t:String)) => throw InvalidTimeTrialParameter(t)
      case _ => throw exceptionSelection(sc,s)
    }
  }

  implicit def inputStream2String(inputStream: InputStream):String = {
    new BufferedReader(new InputStreamReader(inputStream)).readLine()
  }


  private val scSTRING: StringContext = StringContext("","")

  /**
   * Parses TimeTrial object from a plain text String.
   * This only matches the exact format generated by [[ai.dragonfly.monotomni.TimeTrial.STRING]]: e.g. `42:3:1614218679808`
   * @param s a String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the String
   */
  def STRING(s:String): TimeTrial = parse(scSTRING, s)

  private val scJSON: StringContext = StringContext("{\"t\":\"", "\"}")

  /**
   * Parses TimeTrial object from JSON String.
   * This does not parse generally formatted JSON! It only matches the exact format generated by [[ai.dragonfly.monotomni.TimeTrial.JSON]]: e.g. `{"t":"1614218679808"}`
   * @param rawJSON a JSON String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the JSON String
   */
  def JSON(rawJSON:String):TimeTrial = {
    parse(scJSON, rawJSON)
  }

  private val scXML: StringContext = StringContext("<TimeTrial t=\"","\"/>")
  /**
   * Parses TimeTrial object from XML String.
   * This does not parse generally formatted XML! It only matches the exact format generated by [[ai.dragonfly.monotomni.TimeTrial.XML]]: e.g. {{{<TimeTrial sid="42" trial="96" serverTimeStamp="1614269593663" />}}}
   * @param rawXML an XML String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the XML String
   */
  def XML(rawXML:String):TimeTrial = parse(scXML, rawXML)

  def test():Unit = {
    println(TimeTrial.Formats.helpString)

    import Test._
    Passes( () => TimeTrial.BINARY(TimeTrial().BINARY) )
    Fails( () => TimeTrial.BINARY(Array[Byte](0xff)) )
    Passes( () => TimeTrial.BINARY(Array[Byte](0x12, 0xf, 0xa, 0xb, 0x0, 0xc, 0x1, 0xf)) )
    Fails( () => TimeTrial.BINARY(Array[Byte](0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0x0, 0xea, 0xb, 0xbb, 0xb, 0xff, 0x12, 0xcb, 0xa, 0xb, 0x0, 0xc, 0x1, 0xf)) )
    Passes( () => TimeTrial.STRING(TimeTrial().STRING) )
    Fails( () => TimeTrial.STRING("Blah Blah Blah. ERRROR!") )
    Fails( () => TimeTrial.STRING(scSTRING.s("16140136463221614013646322")) )
    Passes( () => TimeTrial.JSON(TimeTrial().JSON) )
    Fails( () => TimeTrial.JSON("Blah Blah Blah. ERRROR!") )
    Fails( () => TimeTrial.JSON(scJSON.s("97657492195762495819251695732479919247957")) )
    Passes( () => TimeTrial.XML(TimeTrial().XML))
    Passes( () => TimeTrial.XML(TimeTrial.scXML.s(Long.MaxValue)))
    Passes( () => TimeTrial.XML(<TimeTrial t="1614218679808" />.toString) )
    Fails( () => TimeTrial.XML("Blah Blah Blah. ERRROR!") )
    Fails( () => TimeTrial.XML(<TimeTrial t="97657492195762495819251695732479919247957" />.toString) )
    Fails( () => TimeTrial.XML(<TimeTrial />.toString) )
    Fails( () => TimeTrial.XML(<TimeTrial t="1614218679808" extra="Mono+Omni" />.toString) )
    Fails( () => TimeTrial.XML(<TimeTrial serverTimeStamp="1614218679808" />.toString) )
  }
}

@JSExportAll
case class TimeTrial(serverTimeStamp:Long = System.currentTimeMillis()) {
  def BINARY:Array[Byte] = ByteBuffer.allocate(TimeTrial.BYTES).putLong(serverTimeStamp).array()
  def STRING:String = TimeTrial.scSTRING.s(serverTimeStamp)
  def JSON:String = TimeTrial.scJSON.s(serverTimeStamp)
  def XML:String = TimeTrial.scXML.s(serverTimeStamp)
}

@JSExportAll
case class PendingTimeTrial(promisedTimeTrial:Promise[TimeTrial], timeoutMilliseconds: Long, start:Long=System.currentTimeMillis(), moi:MOI = Mono+Omni()) extends Distributable {
  // handle timeout:
  new Timer(s"TimeoutMonitor( PendingTimeTrial( moi:$moi ) )").schedule(
    new TimerTask() {
      override def run():Unit = promisedTimeTrial.tryFailure( new TimeoutException() )
    },
    timeoutMilliseconds
  )
}

object TimeTrialJSONP {
  def test():Unit = {
    import Test._
    Passes(() => TimeTrialJSONP.JSONP(TimeTrialJSONP(System.currentTimeMillis(), TimeTrial(42)).JSONP))
    Fails(() => TimeTrialJSONP.JSONP("Blah Blah Blah. ERRROR!"))
  }

  private val scJSONP = StringContext("monotomni.connection.http.JSONP.logTimeTrial('", "','", "');")
  /**
   * Parses TimeTrial object from JSONP Response Body.
   * Browser environments don't need this method but JVM or Node.js clients can use it to support JSONP calls made from repurposed browser applications, for testing, or for validating server responses.
   * This does not parse generally formatted JavaScript! It matches the exact format generated by [[ai.dragonfly.monotomni.TimeTrialJSONP]]
   * @param rawJSONP a JSON String that encodes a TimeTrial object.
   * @return the TimeTrial object encoded in the JSON String
   */
  def JSONP(rawJSONP:String):TimeTrialJSONP = {
    val seq:Option[Seq[String]] = try { scJSONP.s.unapplySeq(rawJSONP.trim()) } catch { case _:Throwable => throw InvalidTimeTrialJSONP(rawJSONP) }
    seq match {
      case Some(Seq(N2Long(moi),N2Long(t))) => TimeTrialJSONP(
        java.lang.Long.parseLong( moi ),
        TimeTrial(java.lang.Long.parseLong( t ))
      )
      case Some(Seq(t, ts)) => throw InvalidTimeTrialParametersJSONP(t, ts)
      case _ =>  throw InvalidTimeTrialJSONP(rawJSONP)
    }
  }
}

@JSExportAll
case class TimeTrialJSONP(pendingTimeTrialId:MOI, timeTrial:TimeTrial) {
  def JSONP:String = TimeTrialJSONP.scJSONP.s(pendingTimeTrialId, timeTrial.serverTimeStamp)
}

@JSExportAll case class InvalidTimeTrialBinary(bytes:Array[Byte]) extends Exception(s"Invalid TimeTrial.  Expected length: ${TimeTrial.BYTES} but observed length: ${bytes.length} on ${byteArray2String(bytes)}")

@JSExportAll case class InvalidTimeTrialString(s:String) extends Exception(s"""Invalid TimeTrial String: "$s"""")
@JSExportAll case class InvalidTimeTrialJSON(rawJSON:String) extends Exception(s"""Invalid TimeTrial JSON: "$rawJSON"""")
@JSExportAll case class InvalidTimeTrialParameter(t:String) extends Exception(s"Invalid TimeTrial Parameter:\n\tTimeTrial('$t'))")
@JSExportAll case class InvalidTimeTrialXML(rawXML: String) extends Exception(s"""Invalid TimeTrial XML:\n\t"$rawXML"""")
@JSExportAll case class InvalidTimeTrialJSONP(rawJSONP:String) extends Exception(s"""Invalid TimeTrial JSONP: "$rawJSONP"""")

@JSExportAll case class InvalidTimeTrialParametersJSONP(pendingTimeTrialId:String, t:String) extends Exception(s"Invalid Pending TimeTrial JSONP Parameters: moi=$pendingTimeTrialId and t=$t")